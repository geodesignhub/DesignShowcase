{% extends "layout.html" %} {% block body %}
<div class="container">
    <!-- Example row of columns -->
    {% if op['status'] == 1 %}
    <br>
    <div class="row">
        <div class="col-md-12">
            <h2>Diagram Details</h2>
            <small>All the diagrams selected in this design grouped by system. If a diagram has multiple features they are displayed as individual entries.</small>
            <p>&nbsp;</p>
            <table id="diagTable" class="display" cellspacing="0" width="100%">
                <thead>
                    <tr>
                        <th>Diagram</th>
                        <th>Title</th>
                        <th>Funding</th>
                        <th>System</th>
                    </tr>
                </thead>
                <tfoot>
                    <tr>
                        <th>Diagram</th>
                        <th>Title</th>
                        <th>Funding</th>
                        <th>System</th>
                    </tr>
                </tfoot>
                <tbody>
                </tbody>
            </table>
        </div>
    </div>
    <br>
    <br>
    <div class="row">
        <div class="col-md-12">
            <h2>Word Cloud</h2>
            <small>A word cloud is generated by analyzing the titles of diagrams in your design.</small>
            <div id="canvas-container">
                <canvas id="cloudcanvas" class="canvas"></canvas>
            </div>
            <!-- <p><a class="btn btn-secondary" href="#" role="button">View details &raquo;</a></p> -->
        </div>
    </div>
    <br>
    
    <div class="row">
        <div class="col-md-6">
            <h2>Design Synthesis</h2>
            <small>&nbsp;</small> 
           
            <div id="inputmap"></div>
            <!-- <p><a class="btn btn-secondary" href="#" role="button">View details &raquo;</a></p> -->
        </div>
        
        <div class="col-md-6">
            <h2>Diagram Connections</h2><small>Click on the edges to highlight them on the map</small>
            <div id="graphcontainer"></div>
            
        </div>        
    </div>
    <div class="row">
        <div class="col-md-12">
            <small>The chart above shows a natural language analysis of similarity of diagram titles, if two titles of a diagram are similar they are linked with a edge. If a chart is not loaded, please refresh after a few moments, the server may still be computing. </small>
        </div>
    </div>
    
    {% else %}
    <p>{{op['message']}} </p>
    {% endif %}
    <br>
    <br>
    <br>
    <hr>
    <footer>
        <p>&copy; Geodesignhub 2019</p>
    </footer>
</div>
<!-- /container -->{% endblock %} {% block footer %} {% if op['status'] == 1 %}
<script type="text/javascript">
    var svgDrawing = SVG('drawing').size(10, 10);
    
    function miniMapstyleComp(feature) {
        // console.log(feature.properties)
        var curFeature = feature.geometry.type;
        if (curFeature === 'LineString') {
            // console.log(feature)
            return {
                weight: 2,
                opacity: .9,
                color: feature.properties.color,
                dashArray: '',

            };
        } else {
            // var fillColor = getColor(feature.properties.areatype);

            if (feature.properties.areatype == 'project') {
                var fillColor = feature.properties.color;
            } else { // it is policy
                var fillPattern = setSVGStyle(feature.properties.color);
                var fillColor = fillPattern;
            }

            return {
                // fillColor: feature.properties.color,
                // fillColor:'#333333',
                weight: 1,
                stroke: true,
                opacity: 0.9,
                fillColor: fillColor,
                color: feature.properties.color,
                dashArray: '',
                // opacity: 0.2,
                fillOpacity: 0.8,
            };
        }

    }

    function setSVGStyle(reqColor) {
        var pattern = svgDrawing.pattern(6, 6, function(add) {
            // add.rect(5, 5).fill(reqColor)
            add.line(0, 0, 6, 6).stroke({
                width: 1,
                color: reqColor
            })
            add.line(6, 0, 0, 6).stroke({
                width: 1,
                color: reqColor
            })
        });
        return pattern.fill();
    }

    function getColor(type) {

        return type === 'policy' ? '#707070 ' :
            type === 'project' ? '#a69695 ' :
            type === 'red2' ? '#bd0026' :
            type === 'red' ? '#f03b20' :
            type === 'yellow' ? '#FFFF00' :
            type === 'green' ? '#74c476' :
            type === 'green2' ? '#31a354' :
            type === 'green3' ? '#006d2c' :
            type === 'purple' ? '#CFACF7' :
            type === 'purple2' ? '#8D6CBF' :
            type === 'purple3' ? '#601286' :
            type === 'orange' ? '#FFA927' :
            type === 'orange2' ? '#F8872E' :
            type === 'orange3' ? '#FC6B0A' :
            type === 'constraints' ? '#343434' :
            type === 'boundaries' ? '#a6cee3' :
            type === 'boundaries2' ? '#b2df8a' :
            '#808080';
    }


    var bounds = "{{op['data']['bounds']|safe}}";
    var finaldesignJSON = {{op['data']['synthesis']|safe}};
    var diagrams = {{op['data']['diagrams']|safe}};
    var latLngs = bounds.split(',');
    var southWest = L.latLng(latLngs[1], latLngs[0]);
    var northEast = L.latLng(latLngs[3], latLngs[2]);
    var mb = L.latLngBounds(southWest, northEast);
    var inputmap = L.map('inputmap', {
        zoomControl: true,
        minZoom: 6,
        maxZoom: 18,
    });
    var map_features_list = [];
    function onEachFeature(feature, layer) {
        // does this feature have a property named popupContent?
        map_features_list.push({'diagram_id':feature.properties.diagramid, 'layer':layer});
        if (feature.properties && feature.properties.description) {
            layer.bindPopup(feature.properties.description);
        }
    }

    // FeatureGroup is to store editable layers
    var design_features = L.featureGroup().addTo(inputmap);
    

    var inputbaseLayer = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://cartodb.com/attributions">CartoDB</a>',
        maxZoom: 18,
    }).addTo(inputmap);
    inputmap.fitBounds(mb);

    L.geoJSON(finaldesignJSON, {
        onEachFeature: onEachFeature,
        style: miniMapstyleComp,
    }).addTo(design_features);

    // load Synthesis
    // load Wordlcoud
    var wordcloud = {{op['data']['wordfreq']|safe}};
    var fuzzyMatches = {{op['data']['fuzzymatches']|safe}};
    var systems = {{op['data']['systems']|safe}};

    WordCloud(document.getElementById('cloudcanvas'), {
        'list': wordcloud,
        'color': '#7b8a8a'
    });

    for (var i2 = finaldesignJSON.features.length - 1; i2 >= 0; i2--) {
        const curFeat = finaldesignJSON.features[i2];
        const curFeatProps = curFeat['properties'];
        const did = curFeatProps['diagramid'];
        var srank = "";
        for (var i1 = diagrams.length - 1; i1 >= 0; i1--) {
            var cDiagram = diagrams[i1];
            if (cDiagram.id == did) {
                desc = cDiagram.worlddescription;
                var sid = cDiagram.sysid;
                var tranking = cDiagram.rank;
                for (var j1 = systems.length - 1; j1 >= 0; j1--) {
                    var curSys = systems[j1];
                    if (curSys.id === sid) {
                        sysname = curSys.sysname;
                        break;
                    }
                }
                srank = sysname + " " + tranking + " ";
                break;
            }
        }

        $('#diagTable > tbody:last-child').append('<tr><td>' + srank + '</td><td>' + curFeatProps['description'] +'</td><td>' + curFeatProps['fundingtype'] + '</td><td>' + curFeatProps['sysname'] + '</td></tr>');


    }
    var table = $('#diagTable').DataTable({
        "rowGroup": {
            dataSrc: 'group'
        },
        "columnDefs": [{
            "visible": false,
            "targets": 3
        }],
        "order": [
            [3, 'asc']
        ],
        "displayLength": 25,
        "drawCallback": function(settings) {
            var api = this.api();
            var rows = api.rows({
                page: 'current'
            }).nodes();
            var last = null;

            api.column(3, {
                page: 'current'
            }).data().each(function(group, i) {
                if (last !== group) {
                    $(rows).eq(i).before(
                        '<tr class="group"><td colspan="5">' + group + '</td></tr>'
                    );

                    last = group;
                }
            });
        }
    });

    // Order by the grouping
    $('#diagTable tbody').on('click', 'tr.group', function() {
        var currentOrder = table.order()[0];
        if (currentOrder[0] === 2 && currentOrder[1] === 'asc') {
            table.order([2, 'desc']).draw();
        } else {
            table.order([2, 'asc']).draw();
        }
    });
    $('#diagTable tbody').on('click', 'tr', function() {
        var data = table.row(this).data();
        const diagramid = data[0];
        if (diagramid in fuzzyMatches) {
            const related = fuzzyMatches[diagramid];
            console.log(related)
        }

    });
    var graphData = {
        "nodes": [],
        "edges": []
    };
    for (var diagramid in fuzzyMatches) {
        var links = fuzzyMatches[diagramid];
        var desc = "";
        var sysid = "";
        var sysname = "";
        var sysrank = "";
        for (var i3 = diagrams.length - 1; i3 >= 0; i3--) {
            var curDiagram = diagrams[i3];
            if (curDiagram.id == diagramid) {
                desc = curDiagram.worlddescription;
                var sysid = curDiagram.sysid;
                var ranking = curDiagram.rank;
                for (var j3 = systems.length - 1; j3 >= 0; j3--) {
                    var curSys = systems[j3];
                    if (curSys.id === sysid) {
                        sysname = curSys.sysname;
                        syscolor = curSys.syscolor;
                        break;
                    }
                }
                sysrank = sysname + " " + ranking + " " + desc;
                break;
            }
        }
        graphData.nodes.push({
            "size": 0.001,
            "id": diagramid,
            "color": syscolor,
            "label": sysrank,
            "x": Math.random(),
            "y": Math.random()
        });
        for (var k = links.length - 1; k >= 0; k--) {
            var curLink = links[k];
            if (curLink !== 0) {

                graphData.edges.push({
                    "id": diagramid + "-" + curLink,
                    "label":diagramid + "-" + curLink,
                    "source": diagramid,
                    "target": curLink,
                    "size":1,
                    'color': '#ccc'
                });
            }
        }
    }
    
        // object with every neighbors of a node inside:
        sigma.classes.graph.addMethod('neighbors', function(nodeId) {
      var k,
          neighbors = {},
          index = this.allNeighborsIndex[nodeId] || {};
  
      for (k in index)
        neighbors[k] = this.nodesIndex[k];
  
      return neighbors;
    });

    s = new sigma({
         renderers: [
                {
                  container: document.getElementById('graphcontainer'),
                  type: 'canvas' // sigma.renderers.canvas works as well
                }
              ],
        graph: graphData,

        settings: {
            drawLabels: false,
        labelSize: 'proportional',
        defaultEdgeType:'line',
        enableHovering:true,
        edgeColor: "default",
        font:"Open Sans",
        enableEdgeHovering: true,
        edgeHoverColor: 'edge',
        defaultEdgeHoverColor: '#000',
        edgeHoverSizeRatio: 1,
        edgeHoverExtremities: true
        }
    });

    // Add a method to the graph model that returns an

        // We first need to save the original colors of our
        // nodes and edges, like this:
        s.graph.nodes().forEach(function(n) {
          n.originalColor = n.color;
        });
        s.graph.edges().forEach(function(e) {
          e.originalColor = e.color;
        });
  

        // When a node is clicked, we check for each node
        // if it is a neighbor of the clicked one. If not,
        // we set its color as grey, and else, it takes its
        // original color.
        // We do the same for the edges, and we only keep
        // edges that have both extremities colored.
        s.bind('clickNode', function(e) {
          var nodeId = e.data.node.id,
              toKeep = s.graph.neighbors(nodeId);
          toKeep[nodeId] = e.data.node;
  
          s.graph.nodes().forEach(function(n) {
            if (toKeep[n.id])
              n.color = n.originalColor;
            else
              n.color = '#eee';
          });
  
          s.graph.edges().forEach(function(e) {
            if (toKeep[e.source] && toKeep[e.target])
              e.color = e.originalColor;
            else
              e.color = '#eee';
          });
          
          // Since the data has been modified, we need to
          // call the refresh method to make the colors
          // update effective.
          s.refresh();
         
          keep_keys = Object.keys(toKeep).map(function (x) { 
                return parseInt(x, 10); 
            });
          
          for (let index = 0; index < map_features_list.length; index++) {
              const element = map_features_list[index];
              
              if (keep_keys.includes(element.diagram_id)) {
                
              } else {
                element.layer.setStyle({'fillOpacity':0.05});
              }
              
          }

        });
  
        // When the stage is clicked, we just color each
        // node and edge with its original color.
        s.bind('clickStage', function(e) {
          s.graph.nodes().forEach(function(n) {
            n.color = n.originalColor;
          });
  
          s.graph.edges().forEach(function(e) {
            e.color = e.originalColor;
          });
                    
          design_features.eachLayer(function (layer) {
                layer.setStyle({'fillOpacity':0.8});
            });

          // Same as in the previous event:
          s.refresh();
        });

  </script>
{% endif %} {% endblock %}